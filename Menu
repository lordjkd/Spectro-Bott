Bot Status:
- Tempo de Atividade: 0 dias, 0 horas, 0 minutos
- Vers√£o: 1.0.0
- Comandos Executados: 0
- Usu√°rios Atendidos: 0
- Erros Encontrados: 0

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';

// Substitua as informa√ß√µes abaixo com as informa√ß√µes reais do criador ou da equipe
const CREATOR_INFO = {
  name: "Seu Nome ou Nome da Equipe",
  description: "Descri√ß√£o sobre o criador ou equipe",
  contact: "Contato do criador ou equipe (e-mail, perfil social, etc.)"
};

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!criador`
  if (message.content.startsWith(`${PREFIX}criador`)) {
    const creatorEmbed = {
      color: 0x0099ff,
      title: 'Informa√ß√µes do Criador',
      fields: [
        {
          name: 'john',
          value: CREATOR_INFO.name,
          inline: true,
        },
        {
          name: 'Descri√ß√£o',
       

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const FEEDBACK_CHANNEL_ID = 'YOUR_FEEDBACK_CHANNEL_ID'; // Substitua com o ID do canal de feedback

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!feedbackbot`
  if (message.content.startsWith(`${PREFIX}feedbackbot`)) {
    // Extrair a mensagem de feedback
    const feedbackMessage = message.content.slice(`${PREFIX}feedbackbot`.length).trim();

    // Verificar se a mensagem de feedback n√£o est√° vazia
    if (feedbackMessage.length === 0) {
      return message.reply('Por favor, forne√ßa uma mensagem de feedback ap√≥s o comando.');
    }

    // Enviar a mensagem de feedback para o canal especificado
    const feedbackChannel = client.channels.cache.get(FEEDBACK_CHANNEL_ID);
    if (!feedbackChannel) {
      return message.reply('Canal de feedback n√£o encontrado.');
    }

    feedbackChannel.send(`Feedback recebido de ${message.author.tag}:\n${feedbackMessage}`)
      .then(() => {
        message.reply('Seu feedback foi enviado com sucesso! Obrigado!');
      })
      .catch(error => {
        console.error('Erro ao enviar feedback:', error);
        message.reply('Houve um erro ao enviar seu feedback. Tente novamente mais tarde.');
      });
  }
});

// Substitua 'YOUR_BOT_TOKEN' pelo token do seu bot
client.login('YOUR_BOT_TOKEN

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!ping`
  if (message.content === `${PREFIX}ping`) {
    const sent = Date.now

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const BOT_VERSION = '1.0.0'; // Substitua com a vers√£o real do bot

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!versao`
  if (message.content === `${PREFIX}versao`) {
    message.channel.send(`A vers√£o atual do bot √© ${BOT_VERSION}.`);
  }
});

// Substitua 'YOUR_BOT_TOKEN' pelo token do seu bot
client.login('YOUR_BOT_TOKEN');

const { Client, Intents } = require('discord.js');
const fetch = require('node-fetch'); // Biblioteca para fazer requisi√ß√µes HTTP
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const BOT_VERSION = '1.0.0'; // Vers√£o atual do bot
const REPO_OWNER = 'your-github-username'; // Seu nome de usu√°rio no GitHub
const REPO_NAME = 'your-repo-name'; // Nome do seu reposit√≥rio

const GITHUB_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest`;

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', async message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!atualizar`
  if (message.content === `${PREFIX}atualizar`) {
    try {
      const response = await fetch(GITHUB_API_URL);
      const data = await response.json();

      const latestVersion = data.tag_name;
      const updateUrl = data.html_url;
      const releaseNotes = data.body;

      if (latestVersion === BOT_VERSION) {
        message.channel.send('Seu bot j√° est√° na vers√£o mais recente.');
      } else {
        message.channel.send(`H√° uma nova vers√£o dispon√≠vel!\n\n**Vers√£o Atual:** ${BOT_VERSION}\n**√öltima Vers√£o:** ${latestVersion}\n**Notas de Lan√ßamento:**\n${releaseNotes}\n**Atualize Aqui:** ${updateUrl}`);
      }
    } catch (error) {
      console.error('Erro ao verificar atualiza√ß√µes:', error);
      message.channel.send('Houve um erro ao verificar atualiza√ß√µes. Tente novamente mais tarde.');
    }
  }
});

// Substitua 'YOUR_BOT_TOKEN' pelo token do seu bot
client.login('YOUR_BOT_TOKEN');

const { Client, Intents } = require('discord.js');
const { exec } = require('child_process'); // Para executar comandos de sistema
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!reiniciar`
  if (message.content === `${PREFIX}reiniciar`) {
    // Enviar mensagem de aviso
    message.channel.send('Reiniciando o bot... üöÄ').then(() => {
      // Reiniciar o bot
      exec('pm2 restart YOUR_BOT_PROCESS_NAME', (error, stdout, stderr) => {
        if (error) {
          console.error(`Erro ao reiniciar o bot: ${error}`);
          message.channel.send('Houve um erro ao reiniciar o bot. Tente novamente mais tarde.');
          return;
        }
        console.log(`stdout: ${stdout}`);
        console.error(`stderr: ${stderr}`);
      });

      // Terminar o processo atual
      process.exit();
    });
  }
});

// Substitua 'YOUR_BOT_TOK

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!infobot`
  if (message.content === `${PREFIX}infobot`) {
    const serverCount = client.guilds.cache.size;
    const userCount = client.users.cache.size;
    const uptime = client.uptime;
    const uptimeFormatted = formatUptime(uptime);

    const infoEmbed = {
      color: 0x0

{
  "users": [
    "user_id_1",
    "user_id_2"
  ],
  "guilds": [
    "guild_id_1",
    "guild_id_2"
  ]
}

const { Client, Intents } = require('discord.js');
const fs = require('fs'); // Para ler o arquivo JSON
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const BLACKLIST_FILE = './blacklist.json';

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', async message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!blacklist`
  if (message.content === `${PREFIX}blacklist`) {
    try {
      // Ler o arquivo JSON
      const data = fs.readFileSync(BLACKLIST_FILE, 'utf8');
      const blacklist = JSON.parse(data);

      // Obter os usu√°rios e servidores na lista negra
      const blacklistedUsers = blacklist.users.map(id => `<@${id}>`).join(', ') || 'Nenhum usu√°rio';
      const blacklistedGuilds = blacklist.guilds.map(id => `<#${id}>`).join(', ') || 'Nenhum grupo';

      // Criar e enviar o embed com as informa√ß√µes
      const infoEmbed = {
        color: 0x0099ff,
        title: 'Lista Negra',
        fields: [
          {
            name: 'Usu√°rios Banidos',
            value: blacklistedUsers,
          },
          {
            name: 'Grupos Banidos',
            value: blacklistedGuilds,
          },
        ],
        timestamp: new Date(),
      };

      message.channel.send({ embeds: [infoEmbed] });
    } catch (error) {
      console.error('Erro ao ler a lista negra:', error);
      message.channel.send('Houve um erro ao tentar acessar a lista negra. Tente novamente mais tarde.');
    }
  }
});

// Substitua 'YOUR_BOT_TOKEN' pelo token do seu bot
client.login('YOUR_BOT_TOKEN');

{
  "sugestoes": [
    "Sugest√£o 1",
    "Sugest√£o 2"
  ]
}

const { Client, Intents } = require('discord.js');
const fs = require('fs'); // Para ler o arquivo JSON
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const SUGESTOES_FILE = './sugestoes.json';

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', async message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot
  if (message.author.bot) return;

  // Comando `!sugestoes`
  if (message.content === `${PREFIX}sugestoes`) {
    try {
      // Ler o arquivo JSON
      const data = fs.readFileSync(SUGESTOES_FILE, 'utf8');
      const sugestoes = JSON.parse(data).sugestoes;

      // Criar e enviar o embed com as sugest√µes
      const infoEmbed = {
        color: 0x0099ff,
        title: 'Sugest√µes de Melhoria',
        description: sugestoes.length > 0 ? sugestoes.join('\n') : 'Nenhuma sugest√£o recebida ainda.',
        timestamp: new Date(),
      };

      message.channel.send({ embeds: [infoEmbed] });
    } catch (error) {
      console.error('Erro ao ler as sugest√µes:', error);
      message.channel.send('Houve um erro ao tentar acessar as sugest√µes. Tente novamente mais tarde.');
    }
  }
});

// Substitua 'YOUR_BOT_TOKEN' pelo token do seu bot
client.login('YOUR_BOT_TOKEN');

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';

const commands = [
  {
    name: 'botstatus',
    description: 'Exibe o tempo de atividade do bot, a vers√£o atual, o n√∫mero de comandos executados e outras estat√≠sticas.',
  },
  {
    name: 'criador',
    description: 'Exibe informa√ß√µes sobre o criador ou a equipe de desenvolvimento do bot.',
  },
  {
    name: 'feedbackbot [mensagem]',
    description: 'Envia feedback diretamente para o desenvolvedor do bot.',
  },
  {
    name: 'ping',
    description: 'Exibe o tempo de resposta (lat√™ncia) do bot em milissegundos.',
  },
  {
    name: 'versao',
    description: 'Exibe a vers√£o atual do bot.',
  },
  {
    name: 'atualizar',
    
*Comandos Especiais (Somente para Dono):*
{
  "vip_users": {}
}

const { Client, Intents } = require('discord.js');
const fs = require('fs'); // Para ler e escrever o arquivo JSON
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES, Intents.FLAGS.GUILD_MEMBERS] });

const PREFIX = '!';
const VIP_FILE = './vip.json';

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
  loadVIPs();
  setInterval(checkVIPExpirations, 60000); // Verifica expira√ß√µes a cada minuto
});

client.on('messageCreate', async message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot e por bots
  if (message.author.bot) return;

  // Comando `!addvip`
  if (message.content.startsWith(`${PREFIX}addvip`)) {
    // Extrair os argumentos do comando
    const args = message.content.split(' ');
    if (args.length < 3) {
      return message.channel.send('Uso correto: !addvip @usu√°rio [tempo]');
    }

    // Extrair usu√°rio e tempo
    const user = message.mentions.members.first();
    const timeArg = args[2];
    const time = parseTime(timeArg);

    if (!user || isNaN(time)) {
      return message.channel.send('Usu√°rio inv√°lido ou tempo inv√°lido. O tempo deve estar no formato de 1h, 30m, etc.');
    }

    // Adicionar o status VIP
    addVIP(user.id, time);

    message.channel.send(`Status VIP concedido a ${user.user.tag} por ${timeArg}.`);
  }
});

function parseTime(timeStr) {
  const match = timeStr.match(/^(\d+)([dhm])$/);
  if (!match) return NaN;
  const value = parseInt(match[1], 10);
  const unit = match[2];
  let milliseconds = 0;

  if (unit === 'd') {
    milliseconds = value * 24 * 60 * 60 * 1000; // Dias
  } else if (unit === 'h') {
    milliseconds = value * 60 * 60 * 1000; // Horas
  } else if (unit === 'm') {
    milliseconds = value * 60 * 1000; // Minutos
  }

  return milliseconds;
}

function loadVIPs() {
  try {
    const data = fs.readFileSync(VIP_FILE, 'utf8');
    client.vipUsers = JSON.parse(data).vip_users || {};
  } catch (error) {
    console.error('Erro ao carregar VIPs:', error);
    client.vipUsers = {};
  }
}

function saveVIPs() {
  fs.writeFileSync(VIP_FILE, JSON.stringify({ vip_users: client.vipUsers }, null, 2));
}

function addVIP(userId, time) {
  const expiration = Date.now() + time;
  client.vipUsers[userId] = expiration;
  saveVIPs();
}

function checkVIPExpirations() {
  const now = Date.now();
  for (const [userId, expiration] of Object.entries(client.vipUsers)) {
    if (now > expiration) {
      delete client.vipUsers[userId];
    }
  }
  saveVIPs();
}

// Substitua 'YOUR_BOT_TOKEN' pelo token do seu bot
client.login('YOUR_BOT_TOKEN');

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const RPG_CHANNELS = new Set(); // Para armazenar canais que t√™m RPG ativado

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', async message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot e por bots
  if (message.author.bot) return;

  // Comando `!ativarRPG`
  if (message.content === `${PREFIX}ativarRPG`) {
    // Verifica se o RPG j√° est√° ativado no canal
    if (RPG_CHANNELS.has(message.channel.id)) {
      return message.channel.send('O menu RPG j√° est√° ativado neste canal.');
    }

    // Ativa o RPG no canal
    RPG_CHANNELS.add(message.channel.id);
    message.channel.send('Menu RPG ativado! Agora voc√™ pode usar todos os comandos RPG.');

    // Adicione aqui a l√≥gica para ativar os comandos RPG, como exibir um menu RPG ou definir o estado do bot
    // Exemplo: enviar uma mensagem com comandos RPG dispon√≠veis
    const rpgMenu = {
      color: 0x0099ff,
      title: 'Menu RPG',
      description: 'Aqui est√£o os comandos dispon√≠veis no modo RPG:',
      fields: [
        {
          name: '!startQuest',
          value: 'Inicia uma 

const { Client, Intents } = require('discord.js');
const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });

const PREFIX = '!';
const RPG_CHANNELS = new Set(); // Para armazenar canais que t√™m RPG ativado

client.once('ready', () => {
  console.log(`Bot est√° online como ${client.user.tag}`);
});

client.on('messageCreate', async message => {
  // Ignorar mensagens enviadas pelo pr√≥prio bot e por bots
  if (message.author.bot) return;

  // Comando `!ativarRPG`
  if (message.content === `${PREFIX}ativarRPG`) {
    // Verifica se o RPG j√° est√° ativado no canal
    if (RPG_CHANNELS.has(message.channel.id)) {
      return message.channel.send('O menu RPG j√° est√° ativado neste canal.');
    }

    // Ativa o RPG no canal
    RPG_CHANNELS.add(message.channel.id);
    message.channel.send('Menu RPG ativado! Agora voc√™ pode usar todos os comandos RPG.');

    // Adicione aqui a l√≥gica para ativar os comandos RPG, como exibir um menu RPG ou definir o estado do bot
    const rpgMenu = {
      color: 0x0099ff,
      title: 'Menu RPG',
      description: 'Aqui est√£o os comandos dispon√≠veis no modo RPG:',
      fields: [
        {
          name: '!startQuest',
          value: 'Inicia uma nova miss√£o.',
        },
        {
          name: '!equipar [item]',
          value: 'Equipa um item espec√≠fico.',
        },
        {
          name: '!status',
          value: 'Mostra o status atual do jogador.',
        },
        {
          name: '!inventario',
          value: 'Exibe o invent√°rio do jogador.',
        },
        // Adicione mais comandos RPG conforme necess√°rio
      ],
      timestamp: new Date(),
    };

    message.channel.send({ embeds: [rpgMenu] });
  }

  // Comando `!desativarRPG`
  if (message.content === `${PREFIX}desativarRPG`) {
    // Verifica se o RPG est√° ativado no canal
    if (!RPG_CHANNELS.has(message.channel.id)) {
      return message.channel.send('O menu RPG n√£o est√° ativado neste canal.');
    }

    // Desativa o RPG no canal
    RPG_CHANNELS.delete(message.channel.id);
    message.channel.send('Menu R

